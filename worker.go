package mr

//worker.go
import (
	"encoding/json"
	"fmt"
	"hash/fnv"
	"io/ioutil"
	"log"
	"net/rpc"
	"os"
	"sort"
	"time"
)

// for sorting by key.
type ByKey []KeyValue

//maybe should be []mr.KeyValue

func (a ByKey) Len() int           { return len(a) }
func (a ByKey) Swap(i, j int)      { a[i], a[j] = a[j], a[i] }
func (a ByKey) Less(i, j int) bool { return a[i].Key < a[j].Key }

// Map functions return a slice of KeyValue.
type KeyValue struct {
	Key   string
	Value string
}

// task number for each KeyValue emitted by Map.
func ihash(key string) int {
	h := fnv.New32a()
	h.Write([]byte(key))
	return int(h.Sum32() & 0x7fffffff)
}

func Worker(mapf func(string, string) []KeyValue, reducef func(string, []string) string) {

	// send rpc to coordinator asking for a task
	for {
		reply, bien := readyForWork()

		//if there is an error log it
		if !bien {
			//log.Printf("couldn't get work from coordinator, retrying in .5 seconds")
			time.Sleep(500 * time.Millisecond)
			continue
		}
		if reply.Terminate {
			//log.Println("No more tasks available. Terminating.")
			break
		}
		if reply.TaskType == MapTask {
			//fmt.Println("nummap is", reply.NumMap)
			DoMaptask(reply, mapf, reply.NumMap)
			reportTaskDone(reply.TaskType, reply.TaskID)
		} else if reply.TaskType == ReduceTask {
			doReduceTask(reply.TaskID, reply.NReduce, reducef)
			reportTaskDone(reply.TaskType, reply.TaskID)
		} else {
			//log.Fatalf("unknown task type: %v", reply.TaskType)
		}

	}
	time.Sleep(1 * time.Second)
}

func DoMaptask(reply *RequestReply, mapf func(string, string) []KeyValue, numTasks int) {
	file, err := os.Open(reply.FileName)
	if err != nil {
		//log.Fatalf("cannot open %v", reply.FileName)
	}
	contents, err := ioutil.ReadAll(file)
	if err != nil {
		//log.Fatalf("error reading file %v", err)
	}
	file.Close()

	kva := mapf(reply.FileName, string(contents))
	reduceTaskKV := make(map[int][]KeyValue)

	// Group key-value pairs by reduce task partition.
	for _, kv := range kva {
		reduceTaskID := ihash(kv.Key) % numTasks
		reduceTaskKV[reduceTaskID] = append(reduceTaskKV[reduceTaskID], kv)
	}

	// Create intermediate files for each reduce task partition.
	for reduceTaskID, kvpairs := range reduceTaskKV {
		createInterfiles(kvpairs, reply.TaskID, reduceTaskID)
	}
}

func doReduceTask(taskID int, nMap int, reducef func(string, []string) string) {
	//log.Printf("Starting reduce task ID %d with %d map files", taskID, nMap)

	var allKVs []KeyValue

	// Read all KeyValue pairs from intermediate files generated by map tasks.
	for i := 0; i < nMap; i++ {
		filename := fmt.Sprintf("mr-%d-%d", i, taskID)
		file, err := os.Open(filename)
		if err != nil {
			//log.Printf("cannot open %v", filename)
			continue
		}

		dec := json.NewDecoder(file)
		for {
			var kv KeyValue
			if err := dec.Decode(&kv); err != nil {
				break // Assuming EOF is the only error we get.
			}
			allKVs = append(allKVs, kv)
		}
		file.Close()
	}

	// Sort all key-value pairs to ensure keys are grouped together.
	sort.Sort(ByKey(allKVs))

	// Group key/value pairs by key.
	keyValueGroups := make(map[string][]string)
	for _, kv := range allKVs {
		keyValueGroups[kv.Key] = append(keyValueGroups[kv.Key], kv.Value)
	}

	// Create output file for this reduce task.
	outputFile := fmt.Sprintf("mr-out-%d", taskID)
	tmpfile, err := ioutil.TempFile(".", "temp-"+outputFile)
	if err != nil {
		//log.Fatalf("cannot create temp output file: %v", err)
	}
	defer os.Remove(tmpfile.Name()) // Clean up temp file in case of failure.

	// Apply the reduce function to each group of values and write to the temp file.
	for key, values := range keyValueGroups {
		output := reducef(key, values)
		_, err := fmt.Fprintf(tmpfile, "%v %v\n", key, output)
		if err != nil {
			//log.Fatalf("cannot write to temp output file: %v", err)
		}
	}

	// Close the temp file to ensure all writes are flushed to disk.
	if err := tmpfile.Close(); err != nil {
		log.Fatalf("cannot close temp output file: %v", err)
	}

	// Rename the temp file to the final output filename atomically.
	if err := os.Rename(tmpfile.Name(), outputFile); err != nil {
		//log.Fatalf("cannot rename temp output file to final file: %v", err)
	}

	//log.Printf("Completed reduce task ID %d, writing output", taskID)
}

// function for rpc call
func readyForWork() (*RequestReply, bool) {

	args := WorkerArgs{
		WorkerID: os.Getpid(), // Assign the PID to WorkerID
	}
	reply := RequestReply{}
	act := call("Coordinator.TaskRequestHandler", &args, &reply)

	if act {
		//log.Printf("Received task - Type: %v, ID: %d, FileName: %s, nMap is: %d", reply.TaskType, reply.TaskID, reply.FileName, reply.NumMap)
	} else {
		//log.Printf("Failed to receive task from coordinator")
	}

	return &reply, act
}

func reportTaskDone(taskType TaskType, taskId int) (bool, error) {
	args := ReportDoneArgs{
		WorkerID: os.Getpid(), // Assign the PID to WorkerID
		TaskID:   taskId,
		TaskType: taskType,
	}

	reply := DoneReply{}
	act := call("Coordinator.DoneHandler", &args, &reply)
	//log.Printf("finished with taskID: %d, tasktype: %d", taskId, taskType)

	if reply.Terminate {
		//log.Printf("Termination signal received. Exiting.")

		os.Exit(0)
	}

	return act, nil
}

func createInterfiles(kvPairs []KeyValue, mapTaskID int, reduceTaskID int) {
	fileName := fmt.Sprintf("mr-%d-%d", mapTaskID, reduceTaskID)
	file, err := os.OpenFile(fileName, os.O_APPEND|os.O_CREATE|os.O_WRONLY, 0666)
	if err != nil {
		log.Fatalf("Failed to open file for appending: %v", err)
	}
	defer file.Close()

	encoder := json.NewEncoder(file)
	for _, kv := range kvPairs {
		if err := encoder.Encode(&kv); err != nil {
			log.Fatalf("Failed to encode KeyValue: %v", err)
		}
	}
}

// uncomment to send the Example RPC to the coordinator.
// CallExample()

// send an RPC request to the coordinator, wait for the response.
// usually returns true.
// returns false if something goes wrong.
// DO NOT MODIFY
func call(rpcname string, args interface{}, reply interface{}) bool {
	// c, err := rpc.DialHTTP("tcp", "127.0.0.1"+":1234")
	sockname := coordinatorSock()
	c, err := rpc.DialHTTP("unix", sockname)
	if err != nil {
		log.Fatal("dialing:", err)
	}
	defer c.Close()

	err = c.Call(rpcname, args, reply)
	if err == nil {
		return true
	}

	fmt.Println("Unable to Call", rpcname, "- Got error:", err)
	return false
}
